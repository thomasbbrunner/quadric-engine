
#include "math.hpp"

#include "error.hpp"

#include <glm/glm.hpp>

#include <algorithm>
#include <vector>
#include <random>

namespace quad
{
namespace math
{
void add_to_each(std::vector<unsigned int> *vec, unsigned int value)
{
    for (auto &&elem : *vec)
    {
        elem += value;
    }
}

float random(float min, float max)
{
    std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<> dis(min, max);

    // Use dis to transform the random unsigned int generated by gen into a
    // double in [1, 2). Each call to dis(gen) generates a new random double

    return dis(gen);
}

void normalize(std::vector<glm::vec3> *vertices)
{
    for (glm::vec3 &elem : *vertices)
    {
        elem = glm::normalize(elem);
    }
}

void multiply_by_scalar(std::vector<glm::vec3> *vertices, float d)
{
    glm::mat3 trans(d);
    for (glm::vec3 &elem : *vertices)
    {
        elem = trans * elem;
    }
}

float linear_interpolation(float value, const std::vector<float> *range, const std::vector<float> *data)
{
    // range is expected to be sorted
    // range and data are expected to have same length
    if (range->size() != data->size())
    {
        throw quad::fatal_error("range and data don't have the same length",
                                "linear_interpolation()");
    }
    // value is expected to be within range
    if (range->at(std::max_element(range->begin(), range->end()) - range->begin()) <= value)
    {
        throw quad::fatal_error("input value is greater than range " + std::to_string(value),
                                "linear_interpolation");
    }
    auto value_range = std::upper_bound(range->begin(), range->end(), value) - 1;

    float fx0 = data->at(value_range - range->begin());
    float fx1 = data->at(value_range - range->begin() + 1);
    float x0 = range->at(value_range - range->begin());
    float x1 = range->at(value_range - range->begin() + 1);

    float res = fx0 + (fx1 - fx0) / (x1 - x0) * (value - x0);

    return res;
}
} // namespace math
} // namespace quad
